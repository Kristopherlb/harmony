// server/actions/adapters/action-repository-adapter.ts
// Adapter: Adapts SeedableActionRepository to ActionRepositoryPort with domain mapping

import type { IActionRepository } from "../../action-repository";
import type { ActionRepositoryPort } from "../application/ports";
import type { Action, WorkflowExecution, ActionCategory, ExecutionScope, QueryTemplate } from "../domain/types";
import { toDomainAction, toDomainWorkflowExecution, toSharedAction, toSharedWorkflowExecution } from "../domain/mappers";

export class ActionRepositoryAdapter implements ActionRepositoryPort {
  constructor(private repository: IActionRepository) {}

  async getActions(): Promise<Action[]> {
    const shared = await this.repository.getActions();
    return shared.map(toDomainAction);
  }

  async getActionById(id: string): Promise<Action | undefined> {
    const shared = await this.repository.getActionById(id);
    return shared ? toDomainAction(shared) : undefined;
  }

  async getActionsByCategory(category: ActionCategory): Promise<Action[]> {
    const shared = await this.repository.getActionsByCategory(category);
    return shared.map(toDomainAction);
  }

  async createExecution(execution: Omit<WorkflowExecution, "id">): Promise<WorkflowExecution> {
    const sharedExecution = {
      id: "", // Will be generated by repository
      ...execution,
      startedAt: execution.startedAt.toISOString(),
      completedAt: execution.completedAt?.toISOString(),
      approvedAt: execution.approvedAt?.toISOString(),
    };
    const created = await this.repository.createExecution(sharedExecution);
    return toDomainWorkflowExecution(created);
  }

  async getExecution(id: string): Promise<WorkflowExecution | undefined> {
    const shared = await this.repository.getExecution(id);
    return shared ? toDomainWorkflowExecution(shared) : undefined;
  }

  async getExecutionByRunId(runId: string): Promise<WorkflowExecution | undefined> {
    const shared = await this.repository.getExecutionByRunId(runId);
    return shared ? toDomainWorkflowExecution(shared) : undefined;
  }

  async updateExecution(id: string, updates: Partial<WorkflowExecution>): Promise<WorkflowExecution | undefined> {
    const sharedUpdates: any = { ...updates };
    if (updates.startedAt) sharedUpdates.startedAt = updates.startedAt.toISOString();
    if (updates.completedAt) sharedUpdates.completedAt = updates.completedAt.toISOString();
    if (updates.approvedAt) sharedUpdates.approvedAt = updates.approvedAt.toISOString();
    const shared = await this.repository.updateExecution(id, sharedUpdates);
    return shared ? toDomainWorkflowExecution(shared) : undefined;
  }

  async getExecutionsByUser(userId: string): Promise<WorkflowExecution[]> {
    const shared = await this.repository.getExecutionsByUser(userId);
    return shared.map(toDomainWorkflowExecution);
  }

  async getPendingApprovals(scope?: ExecutionScope): Promise<WorkflowExecution[]> {
    const shared = await this.repository.getPendingApprovals(scope);
    return shared.map(toDomainWorkflowExecution);
  }

  async getRecentExecutions(limit?: number, scope?: ExecutionScope): Promise<WorkflowExecution[]> {
    const shared = await this.repository.getRecentExecutions(limit, scope);
    return shared.map(toDomainWorkflowExecution);
  }

  async getQueryTemplates(): Promise<QueryTemplate[]> {
    // QueryTemplate doesn't need domain mapping yet, but keeping interface consistent
    return this.repository.getQueryTemplates();
  }

  async getQueryTemplateById(id: string): Promise<QueryTemplate | undefined> {
    return this.repository.getQueryTemplateById(id);
  }
}
