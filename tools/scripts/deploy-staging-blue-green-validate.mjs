/**
 * tools/scripts/deploy-staging-blue-green-validate.mjs
 *
 * Purpose:
 * - Staging validation helper for `blueprints.deploy.blue-green`.
 * - Starts the blueprint via Console `/api/workflows/run-blueprint`,
 *   using runtime-true inline manifests + `skipBuild`.
 *
 * Usage:
 *   node tools/scripts/deploy-staging-blue-green-validate.mjs \
 *     --base-url https://<staging-console> \
 *     --kubeconfig-secret-ref /artifacts/console/public/secrets/staging.kubeconfig \
 *     --namespace default \
 *     --version v0.0.0-smoke \
 *     --image-ref nginx:1.25-alpine
 *
 * Notes:
 * - Requires that the staging worker can execute Dagger-backed capabilities.
 * - Requires OpenBao secretRefs for kubeconfig to be readable by the worker.
 * - This script never prints secret values.
 */
import fs from 'node:fs/promises';
import process from 'node:process';
import path from 'node:path';

function usage() {
  // eslint-disable-next-line no-console
  console.log(
    [
      'Usage:',
      '  node tools/scripts/deploy-staging-blue-green-validate.mjs --base-url <url> --kubeconfig-secret-ref <ref> --version <v> --image-ref <ref>',
      '',
      'Required:',
      '  --base-url <url>                 Console base URL (e.g. https://console-staging.example.com)',
      '  --kubeconfig-secret-ref <ref>    OpenBao secretRef path to kubeconfig (ISS-001)',
      '  --version <version>              Build ID / release version (used for substitutions)',
      '  --image-ref <image>              Existing image ref to deploy (skipBuild=true)',
      '',
      'Optional:',
      '  --namespace <ns>                 Kubernetes namespace (default: default)',
      '  --workflow-id <id>               Explicit workflowId (default: generated by server)',
      '  --timeout-ms <ms>                Overall timeout (default: 900000)',
      '',
    ].join('\n')
  );
}

function parseArgs(argv) {
  const args = { _: [] };
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--help' || a === '-h') args.help = true;
    else if (a === '--base-url') args.baseUrl = argv[++i];
    else if (a === '--kubeconfig-secret-ref') args.kubeconfigSecretRef = argv[++i];
    else if (a === '--namespace') args.namespace = argv[++i];
    else if (a === '--version') args.version = argv[++i];
    else if (a === '--image-ref') args.imageRef = argv[++i];
    else if (a === '--workflow-id') args.workflowId = argv[++i];
    else if (a === '--timeout-ms') args.timeoutMs = Number(argv[++i]);
    else if (a.startsWith('-')) throw new Error(`Unknown flag: ${a}`);
    else args._.push(a);
  }
  return args;
}

function joinUrl(base, p) {
  const b = String(base).replace(/\/+$/, '');
  const path = String(p).startsWith('/') ? String(p) : `/${String(p)}`;
  return `${b}${path}`;
}

async function fetchJson(url, opts) {
  const res = await fetch(url, opts);
  const text = await res.text();
  let json = undefined;
  try {
    json = text ? JSON.parse(text) : undefined;
  } catch {
    // ignore
  }
  return { ok: res.ok, status: res.status, json, text };
}

async function sleep(ms) {
  return await new Promise((resolve) => setTimeout(resolve, ms));
}

async function waitForResult({ baseUrl, workflowId, timeoutMs }) {
  const url = joinUrl(baseUrl, `/api/workflows/${encodeURIComponent(workflowId)}/result`);
  const deadline = Date.now() + timeoutMs;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const r = await fetchJson(url, { method: 'GET', headers: { Accept: 'application/json' } });
    if (r.ok) return r.json;
    if (Date.now() > deadline) throw new Error(`TIMEOUT_WAITING_FOR_WORKFLOW_RESULT (${workflowId})`);
    await sleep(2000);
  }
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  if (args.help) {
    usage();
    process.exit(0);
  }

  const baseUrl = String(args.baseUrl ?? '').trim();
  const kubeconfigSecretRef = String(args.kubeconfigSecretRef ?? '').trim();
  const version = String(args.version ?? '').trim();
  const imageRef = String(args.imageRef ?? '').trim();
  const namespace = String(args.namespace ?? 'default').trim();

  if (!baseUrl) throw new Error('--base-url is required');
  if (!kubeconfigSecretRef.startsWith('/')) throw new Error('--kubeconfig-secret-ref must be an ISS-001 absolute path');
  if (!version) throw new Error('--version is required');
  if (!imageRef) throw new Error('--image-ref is required');

  const timeoutMs = Number.isFinite(args.timeoutMs) ? args.timeoutMs : 900_000;

  // Read a minimal worker deployment manifest and rely on substitutions in the blueprint.
  const workerYamlPath = path.resolve('deploy/k8s/workers/worker-deployment.yaml');
  const workerYaml = await fs.readFile(workerYamlPath, 'utf8');

  const start = await fetchJson(joinUrl(baseUrl, '/api/workflows/run-blueprint'), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
    body: JSON.stringify({
      blueprintId: 'blueprints.deploy.blue-green',
      workflowId: args.workflowId,
      input: {
        version,
        namespace,
        skipBuild: true,
        imageRef,
        skipFlags: true,
        waitForDrain: false,
        kubeconfigSecretRef,
        manifests: [workerYaml],
      },
    }),
  });
  if (!start.ok) throw new Error(`START_FAILED (${start.status}): ${start.text}`);

  const workflowId = start.json?.workflowId;
  if (typeof workflowId !== 'string' || workflowId.length === 0) throw new Error(`Missing workflowId: ${start.text}`);

  const result = await waitForResult({ baseUrl, workflowId, timeoutMs });
  // eslint-disable-next-line no-console
  console.log(JSON.stringify({ ok: true, workflowId, result }, null, 2));
}

if (process.argv[1] && process.argv[1].endsWith('deploy-staging-blue-green-validate.mjs')) {
  main().catch((err) => {
    // eslint-disable-next-line no-console
    console.error(err?.stack ?? String(err));
    process.exit(1);
  });
}

